# 💍 Promise 

Safely blockchainify any puzzle game. 

## Original technology

The protocol combines an pair. Both developed for this project.

## A mathematical protocol 

There are games to tell stories. There are games to solve mysteries. If there is only one way to solve a level - only one answer - then Promise works.

Any such game old or new can, actually, be run on-chain. 
It can be placing mirrors to guide the laser through the labirynth. It can be finding one concept which unites four pictures. It can be guessing which brand is on the logo. We present a general solution to rule them all.

## A must
Why should we blockchainify games at all? What does it even mean?

Something never possible before blockchain happens. Let's see what Promise brings in.

**Auto money back on non-delivery** 
> Before chains:
> There are a lot of complaints on Google Play. Paid features are often not working.
>
> After:
> Promise auto-returns escrowed money, if the level was not delivered to the user. There is no other way around. 

**Auto payout on win**
> Before chains:
>  Games often just change the rules in the middle. Out of nowhere, they could drastically cut the payout. 
>
> After:
> There is an algorithmic commitment. Promise escrows the money. There is no other way. Users are always auto-payed for the right answer. 

**Auto content quality check**
> Before chains:
> The game 
>
> After:
> Promise shuffles the levels using Algorand's Verifiable Random Functions. Before payment, every user gets a fair sneak peak of the random levels. 
> Statistically the user gets the same high-quality for paid levels.


That's why with Promise you get what you are Promised.

## A game content escrow 
Click the link to see a demo game protected by Promise.
### Safe

From a technical point of view Promise is a gaming escrow. First, it guarantees payout/decincentivizes any fraud. Second, it makes sure 
the content quality is the same as Promised by examples. How can a machine feel the quality? Actually, it can't. But, the user might get a fair sneak peak to decide.
Promise provides random examples of levels before the user pays. The levels are randomly shuffled. So, if the user loved those examples, most likely 
paid ones will be enjoyable as well. 

Which seems important in the age of neural net autogenerated content. Imagine that each person 
receives his own personal generated level. There has to be a way to safely sell and buy personal levels. This way is Promise.

One half of Promise is an escrow with hashed challenge-response pairs. It deincentivizes lying and non-participation for game company and player, guarantees payouts for right answers. This is not a regular escrow, but has a very particular player / game interaction scheme:

1. The player books a question.
2. The oracle has to reveal question's plain text. It has to match the question hash. The plain text can be a link to ipfs with a picture or a whole level folder.
3. If the oracle does not respond in time, player is eligible to call a money-back method.
4. The player sees the question and has to answer before timeout. Otherwise oracle can take his payment.
5. The oracle has to reveal the true (matching the hash) answer before timeout. Otherwise the player receives a compensation.
6. If player's answer matched the oracle answer then he receives a prize. Otherwise oracle just takes his payment. 
7. This question-pair now remains open to everyone. It was a random one, so represents the overall quality of the game. With each play the reputation of the game grows.

This fair scheme is enforced via a state machine implemented in the contract.
The only seeming caveat after this step: what if levels are bad/dumb/fake? What if pre-loaded question-answer pairs are boring or factually incorrect? If the question was "Who invented the light bulb?", the malicious answer could be "hahagametrickedyouandtooksomemoney". Actually, it is handled by the other half of Promise.

# A 

It is handled by

Let's say there are 100 question-answer pairs. They are pre-commited . Then

The other half is shuffler of challenges, which using Verifiable Random Functions, randomly permutates i.e shuffling them.
1. A set of N question-answer pair hashes are pre-loaded into the contract.
2. The state is changed so no new questions can be added. Plus, a future round to 
3. The VRF
4. Knuth-Rao array shuffle is used to permute an array of 1..N. Let's call this permutation $\phi[i]$
5. The state is changed to allow players book challenges. Each next player books $\phi[i + 1]$ question. Which means questions are randomly shuffled.
6. Additional

From a cryptography point of view it's an attempt to 
the statistical verification

The verification looks
1.
2.

#Mark code lines for each 1. step 


