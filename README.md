# Promise - a mathematical protocol to safely blochainify any puzzle game

There are games to tell stories. There are games to solve mysteries. If there is only one way to solve a level - only one answer - then Promise works.
Any such game old or new, be it placing mirrors to guide the laser through the labirynth, finding one concept which unites four pictures, or guessing which brand is on the logo, can be brought to blockchain. 

Why should we blochainify what is not broken? 

> Something never possible pre-blockchain happens. The game can algorithmically Promise payout or scores for the right answer. The game can statistically Promise that the questions/levels would be as high-quality as examples marketed to the user.

Click the link to see a demo game protected by Promise.

## Any puzzle game? But how?

From a technical point of view Promise is a gaming escrow which first gurantees payout/decincentivizes any fraud, second makes sure 
the content quality is even. How can a machine feel the quality? Actually, it can't. But, the user might get a fair sneak peak to decide.
Promise provides random examples of levels before the user pays. The levels are randomly shuffled. So, if the user loved those examples, most likely 
paid ones will be enjoyable as well.

Which seems important in the age of neural net autogenerated content. Imagine that each person 
receives his own personal generated level. There has to be a way to safely sell and buy personal levels. This way is Promise.

One half of Promise is an escrow with hashed challenge-response pairs. It deincentivizes lying and non-participation for game company and player, guarantees payouts for right answers. This is not a regular escrow, but has a very particular player / game interaction scheme:

1. The player books a question.
2. The oracle has to reveal question's plain text. It has to match the question hash. The plain text can be a link to ipfs with a picture or a whole level folder.
3. If the oracle does not respond in time, player is eligible to call a money-back method.
4. The player sees the question and has to answer before timeout. Otherwise oracle can take his payment.
5. The oracle has to reveal the true (matching the hash) answer before timeout. Otherwise the player receives a compensation.
6. If player's answer matched the oracle answer then he receives a prize. Otherwise oracle just takes his payment. 
7. This question-pair now remains open to everyone. It was a random one, so represents the overall quality of the game. With each play the reputation of the game grows.

This fair scheme is enforced via a state machine implemented in the contract.
The only seeming caveat after this step: what if levels are bad/dumb/fake? What if pre-loaded question-answer pairs are boring or factually incorrect? If the question was "Who invented the light bulb?", the malicious answer could be "hahagametrickedyouandtooksomemoney". Actually, it is handled by the other half of Promise. It is handled by

Let's say there are 100 question-answer pairs. They are pre-commited . Then

The other half is shuffler of challenges, which using Verifiable Random Functions, randomly permutates i.e shuffling them.
1. A set of N question-answer pair hashes are pre-loaded into the contract.
2. The state is changed so no new questions can be added. Plus, a future round to 
3. The VRF
4. Knuth-Rao array shuffle is used to permute an array of 1..N. Let's call this permutation $\phi[i]$
5. The state is changed to allow players book challenges. Each next player books $\phi[i + 1]$ question. Which means questions are randomly shuffled.
6. Additional

From a cryptography point of view it's an attempt to 
the statistical verification

The verification looks
1.
2.

#Mark code lines for each 1. step 


